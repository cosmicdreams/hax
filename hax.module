<?php

// TODO remove?
include_once 'HAXService.php';

/**
 * @file
 * Headless Authoring eXperience, all we do is accept calls and make things
 *   haxable in the first place.
 */

//define('HAX_DEFAULT_ELEMENTS', 'video-player wikipedia-query pdf-element lrn-table media-image');

use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Entity\Display\EntityViewDisplayInterface;

/**
 * Implements hook_menu().
 */
/*
function hax_menu() {
  $items['hax-node-save/%node/%'] = array(
    'page callback' => '_hax_node_save',
    'page arguments' => array(1, 2),
    'type' => MENU_CALLBACK,
    'access callback' => '_hax_node_access',
    'access arguments' => array('update', 1),
  );
  $items['hax-file-save/%'] = array(
    'page callback' => '_hax_file_save',
    'page arguments' => array(1),
    'type' => MENU_CALLBACK,
    'access callback' => '_hax_file_access',
    'access arguments' => array('create'),
  );
  $items['hax-app-store/%'] = array(
    'page callback' => '_hax_load_app_store',
    'page arguments' => array(1),
    'type' => MENU_CALLBACK,
    'access callback' => 'user_access',
    'access arguments' => array('use hax'),
  );
  $items['node/%node/hax'] = array(
    'title' => 'HAX mode',
    'description' => 'Edit the node with HAX',
    'page callback' => '_hax_node_form',
    'page arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'access callback' => '_hax_node_access',
    'access arguments' => array('update', 1),
  );
  $items['admin/config/content/hax'] = array(
    'title' => 'HAX',
    'description' => 'Settings for basic customizations to HAX.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('hax_settings'),
    'type' => MENU_NORMAL_ITEM,
    'access arguments' => array('administer site configuration'),
  );
  return $items;
}
/*

/**
 * Implements hook_ENTITY_TYPE_view().
 */
function hax_node_view(array &$build, \Drupal\Core\Entity\EntityInterface $entity, \Drupal\Core\Entity\Display\EntityViewDisplayInterface $display, $view_mode) {

  //$route_name = \Drupal::routeMatch()->getRouteName();
  //if ($route_name == 'hax.node_form' && $view_mode == 'full' && \Drupal::config('hax.settings')->get('hax_autoload_element_node_view')) {
// TODO running into CACHE issues with this when we try to use route... so
// have copied into HaxModeController::hax_node_form() and are seeing if we can
// get it to work there - better route dependence from that?
// We don't want to break the cache in a big bad way.
return;
  if ($view_mode == 'full' && \Drupal::config('hax.settings')->get('hax_autoload_element_node_view')) {

    // generate autoload list
    $elementstring = \Drupal::config('hax.settings')->get('hax_autoload_element_list');
    // blow up based on space
    $elements = explode(' ', $elementstring);
    $components = '';
    foreach ($elements as $element) {
      $component = new stdClass();
      $component->machine_name = $element;
      // pull in from webcomponents location
      $component->file = 'libraries/webcomponents/polymer/bower_components/' . $element . '/' . $element . '.html';
      $element = [
        '#tag' => 'link', // The #tag is the html tag
        '#attributes' => [ // Set up an array of attributes inside the tag
          'href' => base_path() . $component->file,
          'rel' => 'import',
        ],
      ];
      $build['#attached']['html_head'][] = [$element, 'webcomponent-' . $component->machine_name];
    }

    $appStoreConnection = array(
      'url' => base_path() . 'hax-app-store/' . \Drupal::csrfToken()->get(),
    );

    // TODO Tag renders, but you must place
    // <cms-hax open-default end-point body-offset-left app-store-connection>
    // into the input format first. Perhaps what we need to do is create our
    // own input format. Or in the least, this step needs to be in the README.
    // To be explored...

    $build['body'][0]['#text'] =  '
          <cms-hax open-default end-point="' . base_path() . 'hax-node-save/' . $entity->id() . '/' . \Drupal::csrfToken()->get() . '" body-offset-left="' . \Drupal::config('hax.settings')->get('hax_offset_left') . '" app-store-connection=' . "'" . json_encode($appStoreConnection) . "'" . '>'
      . $components .
      check_markup($entity->body[0]->value, $entity->body[0]->format)
      .'</cms-hax>';

  }
}

/**
 * Callback to save just the body field.
 */
/*
function _hax_node_save(\Drupal\node\NodeInterface $node, $token) {
  // ensure we had data PUT here and it is valid
  if ($_SERVER['REQUEST_METHOD'] == 'PUT' && drupal_valid_token($token, 'hax')) {
    // load the data from input stream
    $body = file_get_contents("php://input");
    $node->body[0]->value = $body;
    if (!isset($node->body[0]->format)) {
      $node->body[0]->format = filter_default_format();
    }
    $node->save();
    // send back happy headers
    drupal_add_http_header('Content-Type', 'application/json');
    // define status
    drupal_add_http_header('Status', 200);
    $return = array(
      'status' => 200,
      'message' => t('Save successful!'),
      'data' => $node,
    );
    // output the response as json
    print drupal_json_output($return);
    exit;
  }
}
*/

/**
 * Callback to assemble the hax app store
 */
/*
function _hax_load_app_store($token) {
  // ensure we had data PUT here and it is valid
  if (drupal_valid_token($token, 'hax')) {
    $appStore = \Drupal::moduleHandler()->invokeAll('hax_app_store');
    \Drupal::moduleHandler()->alter('hax_app_store', $appStore);
    $staxList = \Drupal::moduleHandler()->invokeAll('hax_stax');
    \Drupal::moduleHandler()->alter('hax_stax', $staxList);
    // send back happy headers
    drupal_add_http_header('Content-Type', 'application/json');
    // define status
    drupal_add_http_header('Status', 200);
    $return = array(
      'status' => 200,
      'apps' => $appStore,
      'stax' => $staxList,
    );
    // output the response as json
    print drupal_json_output($return);
    exit;
  }
}
*/

/**
 * Permission + Node access check.
 */
/*
function _hax_node_access($op, \Drupal\node\NodeInterface $node, Drupal\Core\Session\AccountInterface $account) {
  if (\Drupal::currentUser()->hasPermission('use hax') && node_access($op, $node)) {
    return TRUE;
  }
  return FALSE;
}
*/

/**
 * Permission + File access check.
 */
/*
function _hax_file_access($op, Drupal\Core\Session\AccountInterface $account) {
  if (\Drupal::currentUser()->hasPermission('use hax') && entity_access('create', 'file', $_FILES['file-upload']['type'])) {
    return TRUE;
  }
  return FALSE;
}
*/

/**
 * Save a file to the file system.
 */
/*
function _hax_file_save($token) {
  $status = 403;
  // check for the uploaded file from our 1-page-uploader app
  // and ensure there are entity permissions to create a file of this type
  if (drupal_valid_token($token, 'hax') && isset($_FILES['file-upload']) && entity_access('create', 'file', $_FILES['file-upload']['type'])) {
    $upload = $_FILES['file-upload'];
    // check for a file upload
    if (isset($upload['tmp_name']) && is_uploaded_file($upload['tmp_name'])) {
      // get contents of the file if it was uploaded into a variable
      $data = file_get_contents($upload['tmp_name']);
      $params = filter_var_array($_GET, FILTER_SANITIZE_STRING);
      // see if we had a file_wrapper defined, otherwise this is public
      if (isset($params['file_wrapper'])) {
        $file_wrapper = $params['file_wrapper'];
      }
      else {
        $file_wrapper = 'public';
      }
      // see if Drupal can load from this data source
      if ($file = file_save_data($data, $file_wrapper . '://' . $upload['name'])) {
        file_save($file);
        $file->url = file_create_url($file->uri);
        $return = array('file' => $file);
        $status = 200;
      }
    }
  }
  // send back happy headers
  drupal_add_http_header('Content-Type', 'application/json');
  // define status
  drupal_add_http_header('Status', 200);
  $return = array(
    'status' => $status,
    'data' => $return,
  );
  // output the response as json
  print drupal_json_output($return);
  exit;
}
*/

/**
 * Present the node form but wrap the content in hax-body tag
 * @param  [type] $node [description]
 * @return [type]       [description]
 */
/*
function _hax_node_form(\Drupal\node\NodeInterface $node) {
  // set page title
  // @FIXME
// drupal_set_title() has been removed. There are now a few ways to set the title
// dynamically, depending on the situation.
// 
// 
// @see https://www.drupal.org/node/2067859
// drupal_set_title(t('HAX edit @title', array('@title' => $node->getTitle())), PASS_THROUGH);

  // fake a component to get it into the head of the document, heavy weighting
  $component = new stdClass();
  $component->machine_name = 'cms-hax';
  // pull in from webcomponents location
// @FIXME
  $component->file = libraries_get_path('webcomponents') . '/polymer/bower_components/cms-hax/cms-hax.html';
  _webcomponents_add_to_head($component, 10000);
  // generate autoload list
  $elementstring = \Drupal::config('hax.settings')->get('hax_autoload_element_list');
  // blow up based on space
  $elements = explode(' ', $elementstring);
  $components = '';
  foreach ($elements as $element) {
    // sanity check
    if (!empty($element)) {
      $components .= '<' . $element . ' slot="autoloader">' . '</' . $element . '>';
    }
  }
  $appStoreConnection = array(
    'url' => base_path() . 'hax-app-store/' . \Drupal::csrfToken()->get(),
  );
  // write content to screen, wrapped in tag to do all the work
  $content = '
  <cms-hax open-default end-point="' . base_path() . 'hax-node-save/' . $node->id() . '/' . \Drupal::csrfToken()->get() . '" body-offset-left="' . \Drupal::config('hax.settings')->get('hax_offset_left') . '" app-store-connection=' . "'" . json_encode($appStoreConnection) . "'" . '>'
  . $components .
    check_markup($node->body[0]->value, $node->body[0]->format)
  .'</cms-hax>';
  return $content;
}
*/

/**
 * Helper function to make outline designer settings more obvious.
 */
/*
function hax_settings($form, &$form_state) {
  $form['hax_offset_left'] = array(
    '#type' => 'textfield',
    '#title' => t('Offset'),
    '#default_value' => \Drupal::config('hax.settings')->get('hax_offset_left'),
    '#description' => t("Helps with theme compatibility when positioning the context menu. Adjust this if HAX context menu doesn't correctly align with the side of your content when editing. Value is in pixels but should not include px. Some themes that mess with box-model may or may not have this issue."),
  );
  // collapse default state
  $form['hax_autoload_element_list'] = array(
    '#type' => 'textfield',
    '#title' => t('Elements to autoload'),
    '#default_value' => \Drupal::config('hax.settings')->get('hax_autoload_element_list'),
    '#maxlength' => 1000,
    '#description' => t("This allows for auto-loading elements known to play nice with HAX. If you've written any webcomponents that won't automatically be loaded into the page via that module this allows you to attempt to auto-load them when HAX loads. For example, if you have a video-player element in your bower_components directory and want it to load on this interface, this would be a simple way to do that. Spaces only between elements, no comma"),
  );
  $hax = new HAXService();
  $baseApps = $hax->baseSupportedApps();
  foreach ($baseApps as $key => $app) {
    // @FIXME
// // @FIXME
// // The correct configuration object could not be determined. You'll need to
// // rewrite this call manually.
// $form['hax_' . $key . '_key'] = array(
//       '#type' => 'textfield',
//       '#title' => t('@name API key', array('@name' => $app['name'])),
//       '#default_value' => variable_get('hax_' . $key . '_key', ''),
//       '#description' => t('See') . ' ' . l(t('@name developer docs', array('@name' => $app['name'])), $app['docs']) . ' ' . t('for details'),
//     );

  }
  return system_settings_form($form);
}
*/

/**
 * Implements hook_hax_app_store().
 */
function hax_hax_app_store() {

  $config = $this->config('hax.settings');

  $hax = new \Drupal\hax\HAXService;
  $apikeys = array();
  $baseApps = $hax->baseSupportedApps();
  foreach ($baseApps as $key => $app) {

    if ($config->get('hax_' . $key . '_key') != '') {
      $apikeys[$key] = $config->get('hax_' . $key . '_key');
    }

  }
  $json = $hax->loadBaseAppStore($apikeys);
  // pull in the core ones we supply
// @FIXME ??? need changes now that restws is in core?
  if (\Drupal::moduleHandler()->moduleExists('file_entity') && \Drupal::moduleHandler()->moduleExists('restws')) {
    $tmp = json_decode(_hax_site_connection());
    array_push($json, $tmp);
  }
  return $json;
}

/**
 * Connection details for this site. This is where
 * all the really important stuff is that will
 * make people freak out.
 */
function _hax_site_connection() {
  global $base_url;
  $parts = explode('://', $base_url);
  // built in support when file_entity and restws is in place
  $json = '{
    "details": {
      "title": "' . t('Internal files') . '",
      "icon": "perm-media",
      "color": "light-blue",
      "author": "Drupal",
      "description": "Drupal site integration for HAX",
      "tags": ["media", "drupal"]
    },
    "connection": {
      "protocol": "' . $parts[0] . '",
      "url": "' . $parts[1] . '",
      "operations": {
        "browse": {
          "method": "GET",
          "endPoint": "file.json",
          "pagination": {
            "style": "link",
            "props": {
              "first": "page.first",
              "next": "page.next",
              "previous": "page.previous",
              "last": "page.last"
            }
          },
          "search": {
          },
          "data": {
          },
          "resultMap": {
            "defaultGizmoType": "image",
            "items": "list",
            "preview": {
              "title": "name",
              "details": "mime",
              "image": "url",
              "id": "uuid"
            },
            "gizmo": {
              "source": "url",
              "id": "uuid",
              "title": "name",
              "type": "type"
            }
          }
        },
        "add": {
          "method": "POST",
          "endPoint": "hax-file-save/' . \Drupal::csrfToken()->get() . '",
          "acceptsGizmoTypes": [
            "image",
            "video",
            "audio",
            "pdf",
            "svg",
            "document",
            "csv"
          ],
          "resultMap": {
            "item": "data.file",
            "defaultGizmoType": "image",
            "gizmo": {
              "source": "url",
              "id": "uuid"
            }
          }
        }
      }
    }
  }';
  return $json;
}

/**
 * Implements hook_page_attachments().
 *
 * Load all attachments for this page.
 */

function hax_page_attachments(array &$attachments) {
  if (!hax_is_current_route_supported()) {
    return NULL;
  }

  // TODO better handled in the HaxModeContorller::hax_node_form() now?

  error_log('in hax_page_attachments');

  // fake a component to get it into the head of the document, heavy weighting
  $component = new \stdClass();
  $component->machine_name = 'cms-hax';
  $component->file = 'libraries/webcomponents/polymer/bower_components/cms-hax/cms-hax.html';
  $element = [
    '#tag' => 'link', // The #tag is the html tag
    '#attributes' => [ // Set up an array of attributes inside the tag
      'href' => base_path() . $component->file,
      'rel' => 'import',
    ],
  ];
  $attachments['#attached']['html_head'][] = [$element, 'webcomponent-' . $component->machine_name];

  // TODO do we need the autoload attachments here, too?

  /*
  $metatag_attachments = &drupal_static('metatag_attachments');

  if (is_null($metatag_attachments)) {
    // Load the meta tags from the route.
    $metatag_attachments = metatag_get_tags_from_route();
  }
  if (!$metatag_attachments) {
    return NULL;
  }

  // If any Metatag items were found, append them.
  if (!empty($metatag_attachments['#attached']['html_head'])) {
    if (empty($attachments['#attached'])) {
      $attachments['#attached'] = [];
    }
    if (empty($attachments['#attached']['html_head'])) {
      $attachments['#attached']['html_head'] = [];
    }

    $head_links = [];
    foreach ($metatag_attachments['#attached']['html_head'] as $item) {
      $attachments['#attached']['html_head'][] = $item;

      // Also add a HTTP header "Link:" for canonical URLs and shortlinks.
      // See HtmlResponseAttachmentsProcessor::processHtmlHeadLink() for the
      // implementation of the functionality in core.
      if (in_array($item[1], ['canonical_url', 'shortlink'])) {
        $attributes = $item[0]['#attributes'];

        $href = '<' . Html::escape($attributes['href']) . '>';
        unset($attributes['href']);
        if ($param = drupal_http_header_attributes($attributes)) {
          $href .= ';' . $param;
        }
        $head_links[] = $href;
      }
    }

    // If any HTTP Header items were found, add them too.
    if (!empty($head_links)) {
      $attachments['#attached']['http_header'][] = [
        'Link',
        implode(', ', $head_links),
        FALSE,
      ];
    }
  }
  */

}

/**
 * Identify whether the current route is supported by the module.
 *
 * @return bool
 *   TRUE if the current route is supported.
 */
function hax_is_current_route_supported() {
  /*
  // If upgrading, we need to wait for database updates to complete.
  $is_ready = \Drupal::service('entity_type.manager')
    ->getDefinition('metatag_defaults', FALSE);
  if (!$is_ready) {
    return FALSE;
  }

  // Ignore admin paths.
  if (\Drupal::service('router.admin_context')->isAdminRoute()) {
    return FALSE;
  }
  */

  return TRUE;
}


